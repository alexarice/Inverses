\documentclass{article}

\title{Inverses in Higher Categories}
\author{Alex Rice}

\usepackage{verbatim}
\usepackage{geometry}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{mathtools}
\usepackage{amsthm}
\usepackage{hyperref}
\usepackage{cleveref}
\usepackage{tikz}
\usepackage{listings}
\usepackage{color}
\usepackage[colorinlistoftodos]{todonotes}
\renewcommand{\comment}[1]{\todo[color=green!40]{#1}}

\usetikzlibrary{positioning}

\usepackage[
backend=biber,
style=numeric,
citestyle=numeric,
maxbibnames=99,
isbn=false,
doi=false,
eprint=false,
block=ragged
]{biblatex}

\addbibresource{../citations/citations.bib}

\DefineBibliographyStrings{english}{%
  bibliography = {References},
}

\newtheorem{theorem}{Theorem}
\newtheorem{prop}{Proposition}
\newtheorem{cor}{Corollary}
\newtheorem{lemma}{Lemma}
\theoremstyle{definition}
\newtheorem{definition}{Definition}
\theoremstyle{remark}
\newtheorem{remark}{Remark}
\newtheorem*{claim}{Claim}

\DeclareMathOperator{\id}{id}

\newcommand{\linv}[1]{{}^\star\!#1}
\newcommand{\rinv}[1]{#1^\star}
\newcommand{\inv}[1]{#1^{-1}}


\begin{document}
\maketitle

The todo list has things I think I should do in orange and questions in green
\listoftodos{}

\begin{abstract}
  \todo{Writing one of these would be good}
\end{abstract}
\section{Introduction}\label{sec:intro}

In the study of higher category theory, the notion of invertibility is central. It is common within higher category theory to not specify that two objects are equal, or that two sides of an equation are equal, but rather specify that there is a higher level equivalence between these two objects. It is usual to say that two objects are equivalent exactly when there is an invertible function between them.

This idea can be seen even in the simplest examples of higher categories. Consider the definition of a monoidal category. It is our intention that given objects \(A\), \(B\) and \(C\) that \(A \otimes (B \otimes C)\) and \((A \otimes B) \otimes C\) represent the same object. However it is often the case that requiring equality between these objects (as in a strict monoidal category) is too restrictive and so the usual definition states that there is a natural isomorphism between them.

This is our first example of invertibility. An isomorphism between \(A\) and \(B\) is a morphism \(f : A \to B\) such that there exists a morphisms \(g : B \to A\) with \(f \circ g = \id_B\) and \(g \circ f = \id_A\). This notion of isomorphism works well throughout standard category theory and even in monoidal categories.

However if generalised higher categories are considered, it can be seen that the problem has just been pushed one level up. We have specified that \(g \circ f\) and \(\id_A\) should be equal, yet have already stated that equality is not the best notion of two objects in a higher category. Ideally we want a collection of data that specifies that \(f\) has an inverse \(g\), and that there is a higher morphisms \(\alpha : g \circ f \to \id_A\) and an inverse \(\beta : \id_A \to g \circ f\), and that there exists a morphism \(\alpha \circ \beta \to \id_{\id_A \to g \circ f}\) and continuing in this fashion. Unfortunately this generates a very unwieldy set of data that is difficult to describe.

A natural way we can talk about data structures like this is through coinduction. The definition of equivalence above can be written nicely by saying that \(f : A \to B\) is an equivalence if there exists a \(g : B \to A\) and equivalences \(f \circ g \to \id_B\) and \(g \circ f \to \id_A\). This is a neat method of defining an equivalence, but also has the advantage of opening up more proof techniques to us. In particular, it allows us to structure proofs coinductively.

Given this coinductive machinery, the definition of equivalence above seems very natural. If we start with our definition of isomorphism, then realise that the equalities introduced should themselves be weakened to equivalences, we end up with the proposed definition. However this is not only way we could have defined invertibility. In type theory and in particular in HoTT~\cite{hottbook}, there are 3 notions of invertibility defined:

\begin{itemize}
\item A quasi-inverse, which is similar to the notion of isomorphism presented already;
\item A bi-inverse, where instead of specifying an inverse to the function \(f\), we instead present separate left and right inverses;
\item A half-adjoint inverse, defined to be the same as the quasi-inverse but with an extra coherence condition.
\end{itemize}

There are certain properties about these invertibility conditions that are important in type theory. Firstly, all 3 definitions are equivalent, in that a function \(f\) has one of these 3 types of inverses, then it also has the other 2. Secondly, definitions 2 and 3 form contractible types. In essence, this means that there is only one way in which they hold up to propositional equality.

Although it seems that these 3 are not applicable to generalised higher categories due to the use of equality in their definitions, they can nonetheless be modified into coinductive definitions suitable for such a category. This paper will present those definitions and to attempt to show that they are all equivalent. Further we will try to present an analogue to contractibility which is suitable for higher categories and investigate whether these data types are contractible.

\section{Background}\label{sec:background}

\subsection{Coinduction}\label{sec:coinduction}

Throughout the paper, we want to use coinductive data structures and many functions will be generated by corecursion, and many proofs made using coinduction. Like inductive data structures, coinductive data structures are able to reference themselves in their definition.

Categorically, coinduction forms the categorical dual of induction. Whereas inductive data structures can be thought of as initial algebras, coinductive data structures may be thought of as terminal coalgebras. To see the differences clearly between these two constructions and how they relate, it will be helpful to go through an example. Since a lot of the language used throughout this paper is type-theoretic, induction and coinduction will be explained in the same way. This has the added benefit of being very precise.

When a type is introduced in type theory, there are four parts of its definition: Type formation, Term formation, a recursion principle, and an induction principle. These will be demonstrated with the example of lists.
\begin{itemize}
\item Type formation tells us how to build the type. For lists, given a type \(A\), the type \(\mathsf{List}(A)\) can be formed.
\item Term formation tells us how terms of the type can be constructed. \(\mathsf{List}(A)\) has multiple constructors. We have \(\mathsf{nil} : \mathsf{List}(A)\), which is a constructor with no arguments and \(\mathsf{cons} : A \to \mathsf{List}(A) \to \mathsf{List}(A)\), which takes two.
\item Recursion lets us form functions out of an inductive type. For lists this says that to form a function \(f : \mathsf{List}(A) \to B\), it suffices to define \(f(\mathsf{nil}) : B\) and define \(f(\mathsf{cons}(a)(xs))\) given the value of \(f(xs)\).
\item Induction is a generalisation of recursion and allows us to define functions \(f : \Pi_{xs : \mathsf{List}(A)} P(xs)\) where \(P\) is a type family of type \(\mathsf{List}(A) \to \mathcal{U}\).
\end{itemize}

A further thing to note is that we will require the use of a slight generalisation of this known as inductive type families. These are described in Section~5.7 of \citetitle{hottbook}~\cite{hottbook}. These allow our inductive types to be parameterised. A good example of this is the vector type, which is a list of specified length. Here our type formation rule says that given a type \(A\) we can get a type \(\mathsf{Vec}(A) : \mathbb{N} \to \mathcal{U}\). Further the term formation rules become \(\mathsf{nil} : \mathsf{Vec}(A)(0)\) and \(\mathsf{cons} : \Pi_{n : \mathbb{N}} A \to \mathsf{Vec}(A)(n) \to \mathsf{Vec}(A)(\mathsf{succ}(n))\). Notice that unlike with lists, which also took a parameter, vectors can not be defined by considering each element of the parameter separately. The recursion and induction rules also need to modified slightly.

Now it will be seen how this differs for coinductive types. For this we will use one of the most common coinductive types, the stream.

\begin{itemize}
\item Type formation remains the same as before. Given any type \(A\) we can form \(\mathsf{Stream}(A)\).
\item Instead of specifying how to form terms, we specify how to deconstruct terms. Streams have two deconstructors: \(\mathsf{head} : \mathsf{Stream}(A) \to A\) and \(\mathsf{tail} : \mathsf{Stream}(A) \to \mathsf{Stream}(A)\).
\item Instead of recursion, we have corecursion, which specifies how to build functions \(f : B \to Stream(A)\). Whereas in recursion, we specified the behaviour of the function on each constructor, in corecursion we specify how to deconstruct the value returned. Therefore it suffices to provide \(\mathsf{head}(f(b)) : A\) and to provide \(\mathsf{tail}(f(b)) : \mathsf{Stream}(A)\), where we can use the function \(f\) when defining \(\mathsf{tail}(f(b))\).
\item Coinduction does not work quite the same as induction, as flipping the arrow no longer works due to the dependency in the type. Instead, if we are trying to prove a predicate \(P : \mathsf{Stream}(A) \to \mathcal{U}\), we can define the predicate coinductively, and then provide a witness to it by corecursion. Coinductive type families will likely be needed to define the predicate.
\end{itemize}

As an example of coinduction, suppose we wanted to prove every element of a stream was even. First we construct the predicate \(P : \mathsf{Stream}(\mathbb{N}) \to \mathcal{U}\) as having deconstructors \(\mathsf{headProof}(xs) = \mathsf{is-even}(\mathsf{head}(xs))\) and \(\mathsf{tailProof}(xs) = P(\mathsf{tail}(xs))\). This could then be proved by corecursion.

\comment{Should there be something on sized types, which are used in the agda formalisation?}

\subsection{\(\omega\)-Categories}\label{sec:categories}

In this paper we want to talk about different structures on \(\omega\)-categories, however there are many different definitions of \(\omega\)-categories, a lot of which are very in depth and complicated. Therefore, similar in style to a paper by \textcite{Cheng2007}, we give a set of conditions that we expect to hold in any reasonable definition of a weak infinity category. We then prove results only using these conditions, and reason that given a precise definition of an infinity category, if one could show that these conditions hold, then our results should follow for free.

\begin{definition}
  The globe category \(\mathbb{G}\) is the category where the objects are the natural numbers and morphisms are generated by
  \begin{align*}
    &\sigma_n : n \to n+1\\
    &\tau_n : n \to n+1
  \end{align*}
  subject to the conditions
  \begin{align*}
    \sigma \circ \sigma &= \tau \circ \sigma\\
    \sigma \circ \tau &= \tau \circ \tau
  \end{align*}
\end{definition}

\begin{definition}
  A globular set \(G\) is a presheaf of \(\mathbb{G}\). We refer to \(G(n)\) as the set of \(n\)-cells and for two \(n\)-cells \(x\) and \(y\) we write \(f: x \to y\) to mean that \(f\) is an \((n+1)\)-cell and
  \begin{align*}
    G(\sigma_n)(f) &= x\\
    G(\tau_n)(f) &= y
  \end{align*}
  where we call \(x\) the source of \(f\) and \(y\) the target of \(f\).
\end{definition}

\begin{definition}
  A globular set with identities and composition is a globular set \(G\) with the following:
  \begin{itemize}
  \item For each \(n\)-cell \(x\), there is an \((n+1)\)-cell, \(\id_x\).
  \item Inductively define composition as follows:
    \begin{itemize}
    \item Given \(n\)-cells \(f: x \to y\) and \(g: y \to z\) there is
      an \(n\)-cell \(g \circ_0 f: x \to z\).
    \item Given \(\alpha: f \to g\) and \(\beta: h \to j\), where the composites \(f \circ_n h\) and \(g \circ_n j\) are well defined, there is a morphism \(\alpha \circ_{n+1} \beta: (f \circ_n h) \to (g \circ_n j)\)
    \end{itemize}
  \end{itemize}
  \(\circ\) will be used to mean \(\circ_0\).\comment{Should I write \(\otimes\) for \(\circ_1\)}
\end{definition}

Once we have a globular set with identities and composition, we have enough to define a notion of equivalence. The most basic notion of invertibility will be given here, as it will be needed to state the remainder of properties that we expect an higher category to obey.

\begin{definition}
  Given a globular set \(G\) with identities and composition, with an \(n > 0\) cell \(f : x \to y\), we say that \(f\) is \emph{invertible} if:
  \begin{itemize}
  \item There exists an \(n\)-cell \(\inv f : y \to x\);
  \item There exists an \((n+1)\)-cell \(f_R: f \circ \inv f \to \id_y\);
  \item There exists an \((n+1)\)-cell \(f_L: \inv f \circ f \to \id_x\).
  \item \(f_R\) is invertible.
  \item \(f_L\) is invertible.
  \end{itemize}
\end{definition}

\begin{remark}
  The previous definition is a coinductive one. Formally, we have defined a coinductive data type, which we could call \(\text{Invertible}(f)\), which references itself (in saying that \(f_R\) and \(f_L\) are themselves invertible), and then have specified that \(f\) is invertible if there is a member of \(\text{Invertible}(f)\). Note that as \(\text{Invertible}\) is dependent on the parameter \(f\), it is in fact a coinductive type family as described in \Cref{sec:coinduction}.
\end{remark}

\begin{remark}\label{descendants}
  Notice that in a globular set \(G\) with identities and composition, given two \(n\)-cells \(x\) and \(y\) with the same source and target, we can define a new globular set \(G\) as follows:
  \begin{itemize}
  \item The \(0\)-cells are the \(n+1\)-cells in \(G\) with source \(x\) and target \(y\);
  \item The \(m\)-cells are the \(n+m+1\)-cells in \(G\) whose source and target lie in the \(m-1\)-cells of the globular set being generated.
  \end{itemize}
  Further it is clear that we can carry over identities and composition to this new globular set.
\end{remark}



\begin{definition}\label{def:higher-cat}
  Consider the standard string diagram diagrammatic calculus for bicategories. We can draw diagrams containing nodes, lines, and areas where areas represent \(0\)-cells, a line between areas representing cells \(x\) and \(y\) represents a \(1\)-cell between \(x\) and \(y\), and node between lines represent \(2\)-cells between the cells those lines represent. These diagrams still represent well formed morphisms in an globular set with identities and composition. In a bicategory we have the theorem that given a planar isotopy of string diagrams, the source and target morphisms are equal.

  In this higher categorical setting we can instead require that given a well typed string diagram, and an isotopy of this diagram, there is a \(3\)-cell from source of the isotopy to the target. We require that this cell is invertible. We say that a globular set \emph{respects the graphical calculus} if it has this property.

  We define a \emph{higher category}\comment{Call this a higher precategory?} to be a globular set with identities and composition such that given any globular set generated as in \cref{descendants} respects the graphical calculus. Further we assume the existence of the following morphisms.
  \begin{itemize}
  \item For \(n>0\) and each \(n\)-cell \(f: x \to y\), there are \(n+1\)-cells, known as unitors, \(\lambda_f: \id_y \circ f \to f\) and \(\rho_f: f \circ \id_x \to f\).
  \item Given \(f,g,h\), \(n>1\)-cells with suitable composition defined, we have an associator \(a_{f,g,h} : (f \circ g) \circ h \to f \circ (g \circ h)\).
  \item For compatible morphisms \(f,g,h,j\), we have an interchanger \(i_{f,g,h,j}(f \circ_n g) \circ (h \circ_n j) \to (f \circ h) \circ_n (g \circ j)\).
  \item For suitable \(f,g\) and \(n > 1\), there is a cell \(\id_f \circ_{n+1} \id_g \to \id_{f \circ_n g}\)
  \end{itemize}
  All these further morphisms must be invertible.
\end{definition}

To end this section we give a small lemma, which demonstrates the use of these higher categories and will also be invaluable later.

\begin{lemma}\label{lem:identity}
  Any identity morphism in a higher category \(G\) is invertible.
\end{lemma}

\begin{proof}
  Let \(x\) be any cell. Take \(\inv {\id_x} = \id_x\) and \({(\id_x)}_R = {(\id_x)}_L = \lambda_{id_x}\). By assumption, \(\lambda_{id_x}\) is invertible. Hence \(\id_x\) is invertible.
\end{proof}

\begin{lemma}\label{lem:inverse-invert}
  Suppose \(f\) is invertible. Then so is \(\inv f\).
\end{lemma}

\begin{proof}
  Let \((\inv f, f_R, f_L, f_R{}I, f_L{}I)\) be a witness that \(f\) is invertible. Then \((f , f_L, f_R, f_L{}I, f_R{}I)\) is a witness that \(\inv f\) is invertible.
\end{proof}

\section{Types of Invertibility}\label{sec:invertibility}

In this section we introduce 2 more types of invertibility. Some theorems are proved that help us to work with them and finally all 3 types of invertibility are shown to imply each other. Throughout this section it will be assumed that we are working in a higher category \(G\).

\subsection{Bi-Invertibility}\label{sec:bi-invertibility}

Normally, throughout mathematics, when saying a map is invertible we specify a single inverse, and show that this cancels the function when composed on the left and the right. Instead we can consider a function either having a left inverse or a right inverse, meaning the inverse only cancels the function on when composed on the left (or right respectively). It usually does not make sense to consider functions which have both a separate left and right inverse as in most scenarios it can be proved that these are equal and any computations will be simplified by treating them as the same.

However, the concept of bi-invertibility (having both a left and right inverse), plays a role in type theory. It can be shown (perhaps not surprisingly) that a morphism being bi-invertible implies that it is invertible in the usual sense. Perhaps more surprisingly, the data for being bi-invertible is in some ways simpler than the data for being invertible, in that it can be shown that any two ways of showing a function is bi-invertible turn out to be equivalent.

First, we must define what we mean for a morphism in a higher category to be bi-invertible, as a generalisation of the idea in type theory.

\begin{definition}
  Given a globular set \(G\) with identities and composition, with an \(n > 0\) cell \(f : x \to y\), we coinductively say that \(f\) is \emph{bi-invertible} if:
  \begin{itemize}
  \item There exists an \(n\)-cell \(\rinv f : y \to x\);
  \item There exists an \(n\)-cell \(\linv f : y \to x\);
  \item There exists an \((n+1)\)-cell \(f_R: f \circ \rinv f \to \id_y\);
  \item There exists an \((n+1)\)-cell \(f_L: \linv f \circ f \to \id_x\).
  \item \(f_R\) is bi-invertible.
  \item \(f_L\) is bi-invertible.
  \end{itemize}
\end{definition}

Next it is shown that invertibility implies bi-invertibility. This is fairly trivial though it will be written out to demonstrate proof by coinduction.

\begin{lemma}\label{lem:inv-to-bi-inv}
  Let \(f : x \to y\) be invertible. Then \(f\) is bi-invertible.
\end{lemma}

\begin{proof}
  This is proven by constructing a corecursive function \(\mathsf{invToBiInv} : \Pi_{f : x \to y} \mathsf{Invertible}(f) \to \mathsf{BiInvertible}(f)\). Given \(I = (f',f_R^i,f_L^i,f_R{}I, f_L{}I) : \mathsf{Invertible}(f)\) we can construct \(\mathsf{invToBiInv}(f)(I)\) by:
  \begin{itemize}
  \item \(\rinv f = f'\);
  \item \(\linv f = f'\);
  \item \(f_R = f_R^i\);
  \item \(f_L = f_L^i\);
  \item \(f_R\) is bi-invertible corecursively by \(\mathsf{invToBiInv}(f_R)(f_R{}I)\);
  \item \(f_L\) is bi-invertible corecursively by \(\mathsf{invToBiInv}(f_L)(f_L{}I)\).
  \end{itemize}
\end{proof}

\noindent Now, one of the most important and complex theorems of the paper is proved.

\begin{theorem}[Composition of Bi-invertible Morphisms]
  For any \(n \in \mathbb{N}\) and bi-invertible cells \(f,g\), \(f \circ_n g\) is bi-invertible if it is well defined.
\end{theorem}
\begin{proof}
  In order to prove the main theorem, the notion of pseudo-bi-invertible morphism is introduced. We define \(f\) to be \emph{pseudo-bi-invertible} if:
  \begin{itemize}
  \item There exist \(\rinv f\), \(\linv f\), \(f_L\), and \(f_R\) as in the definition of bi-invertible.
  \item \(f_L\) and \(f_R\) are the composition of bi-invertible morphisms.
  \end{itemize}

  Next, the following claim is proved, which is slightly weaker than the statement of the main theorem.

  \begin{claim}
    For any \(n \in \mathbb{N}\) and bi-invertible cells \(f,g\), \(f \circ_n g\) is pseudo-bi-invertible if it is well defined.
  \end{claim}
  \begin{proof}[Proof of claim]
    Take a pair of compatible composition. Split into cases on \(n\):
    \begin{itemize}
    \item \(n = 0\): It is required that given bi-invertible \(f : x \to y\) and \(g : y \to z\), that \(g \circ f : x \to z\) is pseudo-bi-invertible. Let:
      \begin{itemize}
      \item \(\rinv {(g \circ f)} = \rinv f \circ \rinv g\)
      \item \(\linv {(g \circ f)} = \linv f \circ \linv g\)
      \item \({(g \circ f)}_R : g \circ f \circ \rinv f \circ \rinv g \to \id_z\) is the morphism
        \begin{equation*}
          a_{g, f, \rinv f \circ \rinv g} \circ (\id_g \circ_1 a_{f,\rinv f, \rinv g}^{-1}) \circ (\id_g \circ_1 (f_R \circ_1 \id_{\rinv g})) \circ (\id_g \circ_1 \lambda_{\rinv g}) \circ g_R
        \end{equation*}
        This may be easier to understand from its string diagram, which is given below:
        \begin{center}
          \begin{tikzpicture}
            \node[draw] (GR) {\(g_R\)};
            \node[on grid, below=1 of GR, draw] (FR) {\(f_R\)};
            \node[on grid, below left=1.5cm and 2.25cm of FR] (Base1) {\(g\)};
            \node[on grid, right=0.75cm of Base1] (Base2) {\(f\)};
            \node[on grid, right=3cm of Base2] (Base3) {\(\rinv f\)};
            \node[on grid, right=0.75cm of Base3] (Base4) {\(\rinv g\)};
            \draw (Base1) to ++(0,1cm) to [out=90,in=180]  (GR);
            \draw (Base4) to ++(0,1cm) to [out=90,in=0] (GR);
            \draw (Base2) to ++(0,0.75cm) to [out=90,in=180] (FR);
            \draw (Base3) to ++(0,0.75cm) to [out=90,in=0] (FR);
          \end{tikzpicture}
        \end{center}
      \item \({(g \circ f)}_L : \linv g \circ \linv f \circ f \circ g \to \id_x\) is the morphism
        \begin{equation*}
          a_{\linv g, \linv f, f \circ g} \circ (\id_{\linv g} \circ_1 a_{})\circ (\id_{\linv g} \circ_1 (f_L \circ_1 \id_g)) \circ (\id_{\linv g} \circ_1 \lambda_g) \circ g_L
        \end{equation*}
        which is given by the diagram:
        \begin{center}
          \begin{tikzpicture}
            \node[draw] (GL) {\(g_L\)};
            \node[on grid, below=1 of GL, draw] (FL) {\(f_L\)};
            \node[on grid, below left=1.5cm and 2.25cm of FL] (Base1) {\(\linv g\)};
            \node[on grid, right=0.75cm of Base1] (Base2) {\(\linv f\)};
            \node[on grid, right=3cm of Base2] (Base3) {\(f\)};
            \node[on grid, right=0.75cm of Base3] (Base4) {\(g\)};
            \draw (Base1) to ++(0,1cm) to [out=90,in=180] (GL);
            \draw (Base4) to ++(0,1cm) to [out=90,in=0] (GL);
            \draw (Base2) to ++(0,0.75cm) to [out=90,in=180] (FL);
            \draw (Base3) to ++(0,0.75cm) to [out=90,in=0] (FL);
          \end{tikzpicture}
        \end{center}
      \end{itemize}

      As \(f\) and \(g\) are bi-invertible we get that \(f_L\), \(g_L\), \(f_R\), and \(g_R\) are bi-invertible and the associators and unitors used are bi-invertible by lemmas~\ref{lem:inv-to-bi-inv} and~\ref{lem:inverse-invert} and hence \({(g \circ f)}_R\) and \({(g \circ f)}_R\) are the composition of bi-invertible cells. Therefore, \(g \circ f\) is pseudo-bi-invertible.
    \item \(n > 0\): It is required that given bi-invertible \(\alpha: f \to g\) and \(\beta: h \to j\) where \(f \circ_{n-1} h\) and \(g \circ_{n-1} j\) are both well defined that \(\alpha \circ_n \beta\) bi-invertible. Let:
      \begin{itemize}
      \item \(\rinv {(\alpha \circ_n \beta)} = \rinv \alpha \circ_n \rinv \beta\)
      \item \(\linv {(\alpha \circ_n \beta)} = \linv \alpha \circ_n \linv \beta\)
      \item Define \({(\alpha \circ_n \beta)}_R\) as the following composition:
        \begin{equation*}
          (\alpha \circ_n \beta) \circ (\rinv \alpha \circ_n \rinv \beta) \overset {i_{\alpha,\beta,\rinv \alpha, \rinv \beta}} \to (\alpha \circ \rinv \alpha) \circ_n (\beta \circ \rinv \beta) \overset {\alpha _R \circ_{n+1} \beta _R} \to \id_g \circ_n \id_j \to \id_{g \circ_{n-1} j}
        \end{equation*}
      \item Similarly, define \({(\alpha \circ_n \beta)}_L\) as the following composition:
        \begin{equation*}
          (\linv \alpha \circ_n \linv \beta) \circ (\alpha \circ_n \beta) \overset {i_{\linv \alpha, \linv \beta, \alpha, \beta}} \to (\linv \alpha \circ \alpha) \circ_n (\linv \beta \circ \beta) \overset {\alpha _L \circ_{n+1} \beta _L} \to \id_f \circ_n \id_h \to \id_{f \circ_n h}
        \end{equation*}
      \end{itemize}
      Now, both \({(\alpha \circ_n \beta)}_R\) and \({(\alpha \circ_n \beta)}_L\) are the compositions of bi-invertible and invertible cells so by \cref{lem:inv-to-bi-inv}, \(\alpha \circ_n \beta\) is pseudo-bi-invertible.
    \end{itemize}
  \end{proof}\comment{is this the correct way to nest a proof in a proof?}

  Now the main theorem statement is proved by corecursion. Take \(n\) and \(f \circ_n g\), a compatible composition, where both \(f\) and \(g\) are bi-invertible. By the claim, \(f \circ_n g\) is pseudo-bi-invertible. A witness that \(f \circ_n g\) is bi-invertible can be constructed as follows:
  \begin{itemize}
  \item Let \(\rinv f\), \(\linv f\), \(f_R\), and \(f_L\) be as in the proof of pseudo-bi-invertibility.
  \item It is known that \(f_R\) and \(f_L\) are the composition of bi-invertible cells. By corecursively applying the theorem we get that \(f_R\) and \(f_L\) are bi-invertible.
  \end{itemize}
\end{proof}\comment{This proof could be split into a definition, lemma, and theorem}

\begin{lemma}[Inverses are bi-invertible]\comment{Do Lemma titles have capitalisation?}\label{lem:inverses}
  Let \(f\) be a bi-invertible cell. Then \(\linv f\) and \(\rinv f\) are bi-invertible.
\end{lemma}
\begin{proof}
  We show \(\rinv f\) is bi-invertible and \(\linv f\) will follow similarly. Define the following:
  \begin{itemize}
  \item \(\rinv {(\rinv f)} = f\)
  \item \(\linv {(\rinv f)} = f\)
  \item \({(\rinv f)}_R: \rinv f \circ f \to \id\) is the morphism:
    \begin{equation*}
      \lambda_{\rinv f \circ f}^{-1} \circ (\rinv {f_L} \circ_1 \id_{\rinv f} \circ_1 \id_f) \circ a_{\linv f, f, \rinv f \circ f} \circ (\id_{\linv f} \circ_1 a_{f, \rinv f, f}^{-1}) \circ (\id_{\linv f} \circ_1 f_R \circ_1 \id_f) \circ (\id_{\linv f} \circ_1 \lambda_f) \circ f_L
    \end{equation*}
    given by the string diagram:
    \begin{center}
      \begin{tikzpicture}
        \node (Finv) {\(\rinv f\)};
        \node [on grid, right=1cm of Finv] (F) {\(f\)};
        \node [on grid, above left=2cm and 0.75cm of Finv, draw] (FR) {\(f_R\)};
        \node [on grid, below left=1.5cm and 1.5cm of FR, draw] (FLInv) {\(\rinv {f_L}\)};
        \node [on grid, above right=2.75cm and 1.25cm of FLInv, draw] (FL) {\(f_L\)};
        \draw (Finv) to ++(0,1.25cm) to[out=90,in=0] (FR);
        \draw (FR) to[out=180,in=90] ++(-0.75cm,-0.75cm) to[out=-90,in=0] (FLInv);
        \draw (FLInv) to[out=180,in=-90] ++(-0.75cm,0.75cm) to[out=90,in=180] (FL);
        \draw (F) to ++(0,1.25cm) to[out=90,in=0] (FL);
      \end{tikzpicture}
    \end{center}
  \item \({(\rinv f)}_L: f \circ \rinv f \to \id\) is given by \(f_R\)
  \end{itemize}
  We get that \({(\rinv f)}_R\) is bi-invertible as it is a composite of bi-invertible morphisms (where \(\rinv {f_L}\) and \(a_{f, \rinv f , f}^{-1}\) are bi-invertible by \cref{lem:inv-to-bi-inv} and the coinductive hypothesis) and \({(\rinv f)}_L\) is trivially bi-invertible.
\end{proof}

\subsection{Half-Adjoint Inverses}\label{sec:hai}

Another type of equivalence is the half-adjoint equivalence. Whereas being bi-invertible was a weakening of being invertible, being a half-adjoint equivalence is a strict strengthening of being an equivalence. This is done by adding a coherence condition which effectively enforces \(f_L\) and \(f_R\) to work well together. It turns out that there are two such coherence conditions we can specify, yet each of these implies the other and so it sufficient to provide one of these\todo{Put a reference for this, or a proof, or both}. This is what gives rise to the name \emph{half}-adjoint equivalence. In \Cref{sec:contractibility}, both coherence conditions will be useful so we will distinguish between them by calling one a left-adjoint inverse and the other a right-adjoint inverse.

\begin{definition}
  Given a globular set \(G\) with identities and composition, with an \(n > 0\) cell \(f : x \to y\), we coinductively say that \(f\) is \emph{right-adjoint invertible}\comment{are these the right way round?} if:
  \begin{itemize}
  \item There exists an \(n\)-cell \(f' : y \to x\).
  \item There exists an \(n+1\)-cell \(\alpha: f \circ f' \to \id_y\).
  \item There exists an \(n+1\)-cell \(\beta: \id_x \to f' \circ f\).
  \item There exists an \(n+2\)-cell \(\gamma: (\lambda_{f'}^{-1} \circ (\beta \circ_1 \id_{f'}) \circ (\id_{f'} \circ_1 \alpha) \circ \rho_{f'}) \to \id_{f'}\).
  \item \(\alpha\) is right-adjoint invertible.\comment{rename these?}
  \item \(\beta\) is right-adjoint invertible.
  \item \(\gamma\) is right-adjoint invertible.
  \end{itemize}

  Where \(\gamma\) can be graphically represented by the following diagram:
  \begin{center}
    \begin{tikzpicture}
      \node (Bottom) {\({f'}\)};
      \node[on grid, above left=1cm and 2.25cm of Bottom, draw] (Cup){\(\beta\)};
      \node[on grid, above right=2cm and 1.5cm of Cup,draw] (Cap){\(\alpha\)};
      \node[on grid, above left=1cm and 2.25cm of Cap] (Top) {\({f'}\)};
      \draw (Bottom) to++(0,2) to[out=90,in=0] (Cap);
      \draw (Cup) to[out=0,in=-90] ++(0.75,1) to[out=90,in=180] (Cap);
      \draw (Cup) to[out=180,in=-90] ++(-0.75,1) to (Top);

      \node[on grid, above right=2cm and 1cm of Bottom, font=\fontsize{20}{24}\selectfont] (Eq) {\(\Rightarrow\)};
      \node[above=0cm of Eq,font=\fontsize{15}{19}\selectfont] (Gamma) {\(\gamma\)};
      \node[on grid, right=2cm of Bottom] (L1) {\({f'}\)};
      \node[on grid, above=4cm of L1] (L2) {\({f'}\)};
      \draw (L1) to (L2);
    \end{tikzpicture}
  \end{center}

  Dually say that \(f\) is \emph{left-adjoint invertible} if:
  \begin{itemize}
  \item There exists an \(n\)-cell \(f' : y \to x\).
  \item There exists an \(n+1\)-cell \(\alpha: f' \circ f \to \id_x\).
  \item There exists an \(n+1\)-cell \(\beta: \id_y \to f \circ f'\).
  \item There exists an \(n+2\)-cell \(\gamma: (\rho_{f}^{-1} \circ (\id_{f} \circ_1 \beta) \circ (\alpha \circ_1 \id_f) \circ \lambda_f) \to \id_f\).
  \item \(\alpha\) is left-adjoint invertible.
  \item \(\beta\) is left-adjoint invertible.
  \item \(\gamma\) is left-adjoint invertible.
  \end{itemize}

  So that \(\gamma\) is:
  \begin{center}
    \begin{tikzpicture}
      \node (Bottom) {\({f}\)};
      \node[on grid, above right=1cm and 2.25cm of Bottom, draw] (Cup){\(\beta\)};
      \node[on grid, above left=2cm and 1.5cm of Cup,draw] (Cap){\(\alpha\)};
      \node[on grid, above right=1cm and 2.25cm of Cap] (Top) {\({f}\)};
      \draw (Bottom) to++(0,2) to[out=90,in=180] (Cap);
      \draw (Cup) to[out=180,in=-90] ++(-0.75,1) to[out=90,in=0] (Cap);
      \draw (Cup) to[out=0,in=-90] ++(0.75,1) to (Top);

      \node[on grid, below right=2cm and 1cm of Top, font=\fontsize{20}{24}\selectfont] (Eq) {\(\Rightarrow\)};
      \node[above=0cm of Eq,font=\fontsize{15}{19}\selectfont] (Gamma) {\(\gamma\)};
      \node[on grid, right=2cm of Top] (L1) {\({f}\)};
      \node[on grid, below=4cm of L1] (L2) {\({f}\)};
      \draw (L1) to (L2);
    \end{tikzpicture}
  \end{center}

  We say \(f\) is \emph{half-adjoint invertible} to mean that it is either left-adjoint or right-adjoint invertible.
\end{definition}

\begin{theorem}
  A half-adjoint invertible morphism is invertible.
\end{theorem}
\begin{proof}
  Suppose \(f\) is right-adjoint invertible. Then let:
  \begin{itemize}
  \item \(\rinv f = {f'}\);
  \item \(\linv f = {f'}\);
  \item \(f_R = \alpha\);
  \item \(f_L = \beta^{-1}\).
  \end{itemize}
  By coinduction \(f_R = \alpha\) is invertible and \(\beta\) is invertible and so, by \cref{lem:inverse-invert}, \(\inv \beta\) is also invertible which means \(f\) is too.
  The case where \(f\) is left-adjoint invertible is similar.
\end{proof}

\begin{cor}
  A half-adjoint invertible morphism is bi-invertible.
\end{cor}

\begin{theorem}\label{thm:bi-inv-to-hai}
  A bi-invertible morphism is right-adjoint invertible. Further this can be done such that \(f' = \rinv f\) and \(\alpha = f_R\).
\end{theorem}
\begin{proof}
  Let \(f\) be bi-invertible. Then as require we set:
  \begin{itemize}
  \item \({f'} = \rinv f\),
  \item \(\alpha = f_R\).
  \end{itemize}
  and then:
  \begin{itemize}
  \item \(\beta\) is given by the following diagram:
    \begin{center}
      \begin{tikzpicture}
        \node (Finv) {\({f'}\)};
        \node [on grid, right=1cm of Finv] (F) {\(f\)};
        \node [on grid, below left=2cm and 0.75cm of Finv, draw] (FRInv) {\(\rinv {f_R}\)};
        \node [on grid, above left=1.5cm and 1.5cm of FRInv, draw] (FL) {\(f_L\)};
        \node [on grid, below right=2.75cm and 1.25cm of FL, draw] (FLInv) {\(\linv {f_L}\)};
        \draw (Finv) to ++(0,-1.25cm) to[out=-90,in=0] (FRInv);
        \draw (FRInv) to[out=180,in=-90] ++(-0.75cm,0.75cm) to[out=90,in=0] (FL);
        \draw (FL) to[out=180,in=90] ++(-0.75cm,-0.75cm) to[out=-90,in=180] (FLInv);
        \draw (F) to ++(0,-1.25cm) to[out=-90,in=0] (FLInv);
      \end{tikzpicture}
    \end{center}
  \item \(\gamma\) is given by the following diagram:
    \begin{center}\comment{possible improvements to this diagram}
      \begin{tikzpicture}
        \node (G) {\({f'}\)};
        \node [on grid, below right=0.25cm and 1.75cm of G, draw] (FR) {\(f_R\)};
        \node [on grid, below right=5cm and 0.75cm of FR] (G') {\({f'}\)};
        \node [on grid, below left=3cm and 0.75cm of G, draw] (FRInv) {\(\rinv {(f_R)}\)};
        \node [on grid, above left=1.5cm and 1.5cm of FRInv, draw] (FL) {\(f_L\)};
        \node [on grid, below right=2.75cm and 1.25cm of FL, draw] (FLInv) {\(\linv {(f_L)}\)};
        \draw (G) to ++(0,-2.25cm) to[out=-90,in=0] (FRInv);
        \draw (FRInv) to[out=180,in=-90] ++(-0.75cm,0.75cm) to[out=90,in=0] (FL);
        \draw (FL) to[out=180,in=90] ++(-0.75cm,-0.75cm) to[out=-90,in=180] (FLInv);
        \draw (FR) to[out=180,in=90] ++(-0.75cm,-0.75cm) to ++(0,-1.25cm) to[out=-90,in=0] (FLInv);
        \draw (FR) to[out=0,in=90] ++(0.75cm,-0.75cm) to (G');

        \node [on grid, below right=2.75cm and 3.75cm of G,font=\fontsize{20}{24}\selectfont] (A1) {\(\Rightarrow\)};
        \node [on grid, above=0.5cm of A1] (A1Text) {isotopy};

        \node [on grid, right=8cm of G] (G1) {\({f'}\)};
        \node [on grid, below left=2cm and 0.75cm of G1, draw] (FRInv1) {\(\rinv {(f_R)}\)};
        \node [on grid, below=1cm of FRInv1, draw] (FR1) {\(f_R\)};
        \node [on grid, above left=1.5cm and 1.5cm of FRInv1, draw] (FL1) {\(f_L\)};
        \node [on grid, below left=1.5cm and 1.5cm of FR1, draw] (FLInv1) {\(\linv {(f_L)}\)};
        \node [on grid, below right=2cm and 0.75cm of FR1] (G'1) {\({f'}\)};
        \draw (G1) to ++(0,-1.25cm) to[out=-90,in=0] (FRInv1);
        \draw (FRInv1) to[out=180,in=-90] ++(-0.75cm,0.75cm) to[out=90,in=0] (FL1);
        \draw (FL1) to[out=180,in=90] ++(-0.75cm,-0.75cm) to ++(0,-2.5cm) to[out=-90,in=180] (FLInv1);
        \draw (FR1) to[out=180,in=90] ++(-0.75cm,-0.75cm) to[out=-90,in=0] (FLInv1);
        \draw (FR1) to[out=0,in=90] ++(0.75cm,-0.75cm) to (G'1);

        \node [on grid, rotate=-90, below left=1.5cm and 1.5cm of G'1,font=\fontsize{20}{24}\selectfont] (A2) {\(\Rightarrow\)};
        \node [on grid, left=1cm of A2] (A2Text) {\((f_R)_R\)};

        \node [on grid, below=8cm of G1] (G2) {\({f'}\)};
        \node [on grid, below=3.5cm of G2] (G'2) {\({f'}\)};
        \node [on grid, below left=1cm and 2.25cm of G2, draw] (FL2) {\(f_L\)};
        \node [on grid, below=1.5cm of FL2, draw] (FLInv2) {\(\linv {(f_L)}\)};
        \draw (G2) to (G'2);
        \draw (FL2) to[out=0,in=90] ++(0.75cm,-0.75cm) to[out=-90,in=0] (FLInv2);
        \draw (FL2) to[out=180,in=90] ++(-0.75cm,-0.75cm) to[out=-90,in=180] (FLInv2);

        \node [on grid, below left=0.75cm and 2.5cm of FL2,font=\fontsize{20}{24}\selectfont] (A3) {\(\Leftarrow\)};
        \node [on grid, above=0.5cm of A3] (A3Text) {\((f_L)_L\)};

        \node [on grid, below=8cm of G] (G3) {\({f'}\)};
        \node [on grid, below=3.5cm of G3] (G'3) {\({f'}\)};
        \draw (G3) to (G'3);
      \end{tikzpicture}
    \end{center}
    As \(\alpha = f_R\), it is bi-invertible. Furthermore, \(\beta\) is a composite of bi-invertible morphisms and inverses of bi-invertible morphisms so is itself bi-invertible. We have that \(\gamma\) consists of a composition of bi-invertible morphisms and isotopies (which are invertible as we are working in a higher category which respects the graphical calculus) so is bi-invertible. Therefore all of these are right-adjoint invertible by coinduction and so \(f\) is right-adjoint invertible.
  \end{itemize}
\end{proof}

\begin{theorem}
  A bi-invertible morphism has a left-adjoint structure with \(f' = \linv f\) and \(\alpha = f_L\).
\end{theorem}
\begin{proof}
  Dual to \Cref{thm:bi-inv-to-hai}.
\end{proof}

\begin{cor}\label{cor:equiv}
  Let \(G\) be a higher category. Let \(n > 0\) and \(f\) be an \(n\)-cell of \(G\). Then the following are equivalent.
  \begin{itemize}
  \item \(f\) is bi-invertible.
  \item \(f\) is invertible.
  \item \(f\) is half-adjoint invertible.
  \end{itemize}
\end{cor}

\section{Contractibility}\label{sec:contractibility}

\Cref{sec:hai} achieves one of the goals set out in the introduction, namely \cref{cor:equiv}. The other property stated was that bi-invertibility and half-adjoint invertibility should be contractible types. In type theory, a type is contractible if there is an element in that type which all other terms of that type are propositionally equal to. Any contractible type is then equivalent to the unit type. The natural analogue to the higher categorical setting would be to say that a category is contractible if it is equivalent to the terminal category.

\begin{definition}
  The terminal globular set \(T\) is the globular set with exactly one \(n\) cell for each \(n\). There is then only one choice for the source and target of each cell and all required equations hold by this uniqueness.
  We can further add identities and composition to this globular set. There is only one way these could be defined due to uniqueness.
\end{definition}

What this does not answer is what a suitable notion of equivalence should be. As this could be dependent of the specific definition of a higher category, we do not try to answer this here. Instead, we give a notion of contractibility based on the work that has already been done.

\begin{definition}
  Let \(G\) be a globular set with identities and composition. \(G\) is \emph{contractible} if given any two \(0\)-cells \(x\) and \(y\), there is an invertible cell \(f : x \to y\) and for any \(n\)-cells \(f : x \to y\) and \(g : x \to y\) there should be an invertible cell \(f \to g\).
\end{definition}

In this section we aim to define a higher category of cells between invertibility data. While the task of showing contractibility falls beyond the scope of this paper, we do manage to prove partial contractibility results for the half-adjoint and bi-invertible cases, and suggest how these could be continued.

We start with bi-invertibility. The definition of the cells between these types is largely inspired by~\cite[Lemma 4.2.5]{hottbook}. This gives us a compositional way to think about equivalence between these two types. It can be formulated as follows: Suppose we have a cell \(f : x \to y\) and two bi-invertible structures on it \((\rinv f, \linv f, f_R, f_L, f_R{}BI, f_L{}BI)\) and \((\rinv f{}' , \linv f{}', f_R', f_L', f_R{}BI', f_L{}BI')\). A cell is made coinductively from the following parts:
\begin{itemize}
\item A bi-invertible cell \(\gamma_R : \rinv f \to \rinv f{}'\);
\item A bi-invertible cell \(\delta_R : (\id_f \circ_1 \gamma_R) \circ f_R' \to f_R\);
\item A cell from the induced bi-invertible structure on \((\id_f \circ_1 \gamma_R) \circ f_R'\) to \(f_R{}BI\);
\item The equivalent for \(\gamma_L\), \(\delta_L\) and coinductive part.
\end{itemize}

It should be noted that this is quite a natural way to define a cell between these structures. We simply defined a cell for each part of the structure separately, with pretty much only one way of defining each such cell. The only oddity may be that we require these cells to be bi-invertible. This is simply so that \((\id_f \circ_1 \gamma_R) \circ f_R'\) has a canonical bi-invertible structure. Given this, the construction can be continued. Suppose we have \((\gamma_R, \delta_R, BI_R, \gamma_L, \delta_L, BI_L)\) and \((\gamma_R', \delta_R', BI_R', \gamma_L', \delta_L', BI_L')\). Then a cell is:
\begin{itemize}
\item A bi-invertible cell \(\gamma_R \to \gamma_R'\)
\item A bi-invertible cell from:
  \todo{diagram here}
  to \(\delta_R\)
\item Similar constructions for the remainder of the parts.
\end{itemize}

We conjecture that continuing in this way will generate a higher category structure. Next is the main result of this section.

\todo{main result}

\todo{invertibility and half-adjoints}

\todo{how to continue}

\section{Related Work}\label{sec:related}

\todo{section}

\section{Formalisation}\label{sec:formalisation}

\todo{section}

\section{Conclusion}\label{sec:conclusion}

\todo{conclusion}

\printbibliography{}
\end{document}